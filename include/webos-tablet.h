/* Generated by wayland-scanner 1.11.0 */

#ifndef WEBOS_TABLET_CLIENT_PROTOCOL_H
#define WEBOS_TABLET_CLIENT_PROTOCOL_H

#include <stdint.h>
#include <stddef.h>
#include "wayland-client.h"

#ifdef  __cplusplus
extern "C" {
#endif

/**
 * @page page_webos_tablet The webos_tablet protocol
 * @section page_ifaces_webos_tablet Interfaces
 * - @subpage page_iface_wl_webos_tablet - interface for handling tablet events
 * @section page_copyright_webos_tablet Copyright
 * <pre>
 *
 * Copyright (c) 2018-2020 LG Electronics, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * </pre>
 */
struct wl_webos_tablet;

/**
 * @page page_iface_wl_webos_tablet wl_webos_tablet
 * @section page_iface_wl_webos_tablet_desc Description
 *
 * This interface handles tablet events that is not implemented
 * in the standard protocol.
 * @section page_iface_wl_webos_tablet_api API
 * See @ref iface_wl_webos_tablet.
 */
/**
 * @defgroup iface_wl_webos_tablet The wl_webos_tablet interface
 *
 * This interface handles tablet events that is not implemented
 * in the standard protocol.
 */
extern const struct wl_interface wl_webos_tablet_interface;

#ifndef WL_WEBOS_TABLET_POINTER_TYPE_ENUM
#define WL_WEBOS_TABLET_POINTER_TYPE_ENUM
/**
 * @ingroup iface_wl_webos_tablet
 * pointer type
 *
 * Describes the type of the pointer.
 */
enum wl_webos_tablet_pointer_type {
	WL_WEBOS_TABLET_POINTER_TYPE_UNKNOWN = 0,
	WL_WEBOS_TABLET_POINTER_TYPE_PEN = 1,
	WL_WEBOS_TABLET_POINTER_TYPE_CURSOR = 2,
	WL_WEBOS_TABLET_POINTER_TYPE_ERASE = 3,
};
#endif /* WL_WEBOS_TABLET_POINTER_TYPE_ENUM */

/**
 * @ingroup iface_wl_webos_tablet
 * @struct wl_webos_tablet_listener
 */
struct wl_webos_tablet_listener {
	/**
	 * tablet event
	 *
	 * Represents a tablet event containing various information. Some
	 * value may not be available depending on the driver used.
	 */
	void (*tablet_event)(void *data,
			     struct wl_webos_tablet *wl_webos_tablet,
			     struct wl_array *uniqueId,
			     int32_t pointerType,
			     int32_t buttons,
			     wl_fixed_t globalX,
			     wl_fixed_t globalY,
			     int32_t xTilt,
			     int32_t yTilt,
			     wl_fixed_t pressure,
			     wl_fixed_t rotation);
};

/**
 * @ingroup wl_webos_tablet_iface
 */
static inline int
wl_webos_tablet_add_listener(struct wl_webos_tablet *wl_webos_tablet,
			     const struct wl_webos_tablet_listener *listener, void *data)
{
	return wl_proxy_add_listener((struct wl_proxy *) wl_webos_tablet,
				     (void (**)(void)) listener, data);
}


/** @ingroup iface_wl_webos_tablet */
static inline void
wl_webos_tablet_set_user_data(struct wl_webos_tablet *wl_webos_tablet, void *user_data)
{
	wl_proxy_set_user_data((struct wl_proxy *) wl_webos_tablet, user_data);
}

/** @ingroup iface_wl_webos_tablet */
static inline void *
wl_webos_tablet_get_user_data(struct wl_webos_tablet *wl_webos_tablet)
{
	return wl_proxy_get_user_data((struct wl_proxy *) wl_webos_tablet);
}

static inline uint32_t
wl_webos_tablet_get_version(struct wl_webos_tablet *wl_webos_tablet)
{
	return wl_proxy_get_version((struct wl_proxy *) wl_webos_tablet);
}

/** @ingroup iface_wl_webos_tablet */
static inline void
wl_webos_tablet_destroy(struct wl_webos_tablet *wl_webos_tablet)
{
	wl_proxy_destroy((struct wl_proxy *) wl_webos_tablet);
}

#ifdef  __cplusplus
}
#endif

#endif
